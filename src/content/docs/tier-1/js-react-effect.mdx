---
title: useEffectについて
---

## 副作用(Side Effects)とは？
React のコンポーネントは、基本的に「入力(props, state)→ 出力(UI)」という流れで動作します。
しかし、コンポーネントのレンダリングとは直接関係のない処理(例: データの取得、購読の登録、DOM の操作など)が必要な場合があります。
これらの処理は「副作用(Side Effects)」と呼ばれます。そういった副作用を適切に管理するために、React では useEffect フックが用意されています。

## useEffectの使い方
実際にコードを書いて、useEffect の使い方を学んでいきましょう。
ここでは、ut.code(); Learn のプロジェクトである[ストップウォッチ](https://learn.utcode.net/docs/trial-session/project/)を React で実装することを考えます。

### Step 0: 環境構築
vite を使って、環境構築していきます。
ここでは、パッケージマネージャーとして bun を用いますが、npm でも問題ありません。
```sh
bun create vite@latest
```
プロジェクトの名前を foo にしたと仮定して、話を進めます。
```sh
cd foo
bun dev
```
これで http://localhost:5173 を開いて vite のデフォルトのページが表示されれば、環境構築は完了です。

### Step 1: 副作用の宣言
まずは、ページを開いたと同時に時間が経過していく、簡単なストップウォッチを作ってみましょう。src/App.tsx を編集していきます。
useEffect の第一引数には、副作用として実行したい関数を与えます。この場合、その関数はコンポーネントがレンダリングされた**後に**実行されます。
何秒たったかページに表示させるために、time という状態を定義します。
副作用として、「1000ミリ秒ごとに time を 1 だけ増やす」というのが今回やりたいことになります。
setInterval 関数を使えば、n ミリ秒ごとにコールバック関数を実行できるというのは、ut.code(); Learn でも出てきましたね。
```js
// App.tsx
import { useEffect, useState } from "react";

export default function App() {
  const [time, setTime] = useState(0);
  useEffect(() => {
    setInterval(() => setTime(time + 1), 1000)
  })
  return <div>time: {time}</div>
}
```
useEffect や setInterval のコールバック関数が無名関数で定義されているのはどうしてでしょうか？
関数は () がついたタイミングで評価されるので、例えば `setTime(time + 1)` を setInterval 関数の引数として直接渡すことはできないのです！

### Step 2: ストップウォッチが加速する！？
Step 1 で作ったストップウォッチには一つ致命的な問題があります。それは、少し時間を経過させると分かります。
そう、加速するのです！！
これはどうしてでしょうか？先ほどコンポーネントがレンダリングされた後に副作用が実行されると説明しましたが、ではコンポーネントがレンダリングされるのはいつでしょうか？
[ut.code(); Learn](https://learn.utcode.net/docs/advanced/react/) で説明されているように、状態が更新される度にレンダリングされるのです！
つまり、time が更新される度にタイマーが作られるのですね！それがストップウォッチが加速する理由になります。
ではどうやってこの問題を解決すればよいでしょうか？
コンポーネントがDOMから削除された（アンマウントされた）ときに、タイマーも削除すればいいですね！
useEffect では、コールバック関数の返り値として関数（クリーンアップ関数といいます）を指定することで、コンポーネントがアンマウントされたときにクリーンアップ関数が実行されます。
clearInterval を使ってタイマーを削除すればいいですね！
```js
import { useEffect, useState } from "react";

export default function App() {
	const [time, setTime] = useState(0);
	useEffect(() => {
		const timerID = setInterval(() => setTime(time + 1), 1000);
		return () => clearInterval(timerID);
	});
	return <div>time: {time}</div>;
}
```
まあ setInterval の代わりに setTimeOut を使えば、この場合はクリーンアップ関数は要らないんですけど、クリーンアップ関数の説明がしたかったので、setInterval を使いました。

### Step 3: スタートボタンの実装
次に、スタートボタンを実装してみましょう。このままだと、ページが読み込まれたときにどうしてもタイマーが作動してしまいます。
そこで、running という状態を定義して、running が true のときだけ、タイマーが作動するようにしましょう。
```js
import { useEffect, useState } from "react";

export default function App() {
	const [time, setTime] = useState(0);
	const [running, setRunning] = useState(false);
	useEffect(() => {
		if (running) {
			const timerID = setInterval(() => setTime(time + 1), 1000);
			return () => clearInterval(timerID);
		}
	});
	return (
		<>
			<button onClick={() => setRunning(true)}>Start</button>
			<div>time: {time}</div>
		</>
	);
}
```

### Step 4: ストップボタンの実装
ストップボタンの実装について考えてみましょう。



## 別の副作用の例